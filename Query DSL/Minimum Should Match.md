# Minimum Should Match （最少应该匹配）

`minimum_should_match`可以接受的参数：

|参数|例子|说明|
|---|----|---|
|整数|3|表示一个固定值，不考虑可选子句的数量|
|负整数|-2|可选子句的数量减去这个数字，表示必须匹配的数量|
|百分数|75%|可选子句的数量乘以百分数，表示必须匹配的数量。从百分比计算的数字向下舍入并用作最小值|
|负百分数|-25%|表示可选子句总数量的百分比可以缺少。从百分比计算的数字向下舍入，然后从总数量中减去该值，来决定匹配的最小值。|
|组合|3<90%|正整数，后面跟一个小于号，然后跟一个上面提到过的说明符，这是一个条件规范。它表示如果可选子句的数量小于等于第一个整数，则所有的子句都是必须的，但是如果大于第一个整数，则适用第二个值。在这个例子中，如果有1到3个子句，则它们都是必须的；如果有4个或更多的子句，则只有90%的子句是必须的。|
|多种组合|2<-25% 9<-3|多个条件规范可以用空格分隔，每个值只有比前一个值大才是有效的。如果只有一个或两个子句则它们都是必须的；如果有3到9个子句，则总数减去25%的子句是必须的；如果子句数量大于9个，则总数减去3的子句是必须的。|

注意：

当处理百分数时，使用负值会在一些边界条件上有不同的行为。75%和-25%在处理4个子句时是一样的，但是在处理5个子句时，75%意味着需要3个，-25%意味着需要4个。

如果基于条件规范的计算确定不需要可选子句，则关于`BooleanQueries`的通常规则在搜索时仍然适用（不包含必须子句的`BooleanQueries`仍然必须匹配至少一个可选子句）。

不论计算出的结果如何，永远不会使用大于可选子句的值，或者小于1的值。无论计算结果是多么低或多高，所需匹配的最小数量将永远不会小于1或大于子句的数量。
